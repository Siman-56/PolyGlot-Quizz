<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PolyGlot Quiz Generator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;600;700&family=Work+Sans:wght@300;400;500;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            --ink: #ffffff;
            --paper: rgb(34, 154, 255);
            --accent: #ffffff;
            --accent-soft: rgba(255, 255, 255, 0.3);
            --accent-darker: rgba(255, 255, 255, 0.9);
            --muted: rgba(255, 255, 255, 0.8);
            --border: rgba(255, 255, 255, 0.3);
            --highlight: rgba(255, 255, 255, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Work Sans', sans-serif;
            background: var(--paper);
            color: var(--ink);
            line-height: 1.6;
            overflow-x: hidden;
            margin: 0;
            padding: 0;
        }

        /* Decorative background pattern */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.02;
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 2px, var(--accent) 2px, var(--accent) 3px),
                repeating-linear-gradient(90deg, transparent, transparent 2px, var(--accent) 2px, var(--accent) 3px);
            background-size: 30px 30px;
            pointer-events: none;
            z-index: 0;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 60px 30px;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            margin-bottom: 80px;
            animation: fadeInDown 0.8s ease-out;
        }

        h1 {
            font-family: 'Cormorant Garamond', serif;
            font-size: clamp(3rem, 8vw, 5.5rem);
            font-weight: 700;
            letter-spacing: -0.02em;
            line-height: 1;
            margin-bottom: 20px;
            color: var(--ink);
        }

        .subtitle {
            font-size: 1.1rem;
            color: var(--muted);
            font-weight: 300;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .section {
            background: rgba(0, 0, 0, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.4);
            padding: 40px;
            margin-bottom: 30px;
            position: relative;
            box-shadow: 8px 8px 0 rgba(0, 0, 0, 0.2);
            animation: fadeInUp 0.8s ease-out;
            animation-fill-mode: both;
            backdrop-filter: blur(10px);
        }

        .section:nth-child(2) { animation-delay: 0.1s; }
        .section:nth-child(3) { animation-delay: 0.2s; }
        .section:nth-child(4) { animation-delay: 0.3s; }

        .section::before {
            content: '';
            position: absolute;
            top: -2px;
            left: 20px;
            width: 80px;
            height: 2px;
            background: white;
        }

        h2 {
            font-family: 'Cormorant Garamond', serif;
            font-size: 2rem;
            font-weight: 600;
            margin-bottom: 25px;
            color: var(--ink);
        }

        .upload-zone {
            border: 3px dashed rgba(255, 255, 255, 0.5);
            padding: 50px 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .upload-zone::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: white;
            opacity: 0.15;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s ease, height 0.6s ease;
        }

        .upload-zone:hover::before {
            width: 500px;
            height: 500px;
        }

        .upload-zone:hover {
            border-color: white;
            background: rgba(255, 255, 255, 0.2);
        }

        .upload-zone.dragover {
            background: rgba(255, 255, 255, 0.25);
            border-color: white;
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.8;
        }

        .upload-text {
            font-size: 1.1rem;
            color: white;
            position: relative;
            z-index: 1;
        }

        input[type="file"] {
            display: none;
        }

        .file-info {
            margin-top: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.15);
            border-left: 4px solid white;
            display: none;
            animation: slideIn 0.4s ease;
        }

        .file-info.visible {
            display: block;
        }

        .file-name {
            font-weight: 600;
            color: white;
            font-size: 1.1rem;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .stat-value {
            font-family: 'Cormorant Garamond', serif;
            font-size: 2rem;
            font-weight: 700;
            color: white;
        }

        .stat-label {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.8);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .controls {
            display: grid;
            gap: 25px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        label {
            font-weight: 500;
            color: var(--ink);
            font-size: 0.95rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        select, input[type="number"] {
            padding: 12px 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-family: 'Work Sans', sans-serif;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        select option {
            background: rgb(34, 154, 255);
            color: white;
        }

        select:focus, input[type="number"]:focus {
            outline: none;
            border-color: white;
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.15);
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 10px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            user-select: none;
        }

        input[type="checkbox"] {
            width: 22px;
            height: 22px;
            cursor: pointer;
            accent-color: white;
        }

        button {
            padding: 18px 40px;
            background: white;
            color: rgb(34, 154, 255);
            border: none;
            font-family: 'Work Sans', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            margin-top: 20px;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(34, 154, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s ease, height 0.6s ease;
        }

        button:hover::before {
            width: 300px;
            height: 300px;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.95);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        button:disabled {
            background: rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.6);
            cursor: not-allowed;
            transform: none;
        }

        button:disabled:hover {
            box-shadow: none;
        }

        .quiz-container {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .quiz-container.active {
            display: block;
        }

        .quiz-header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 30px;
            border-bottom: 2px solid var(--border);
        }

        .quiz-title {
            font-family: 'Cormorant Garamond', serif;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .quiz-progress {
            font-size: 1.1rem;
            color: var(--muted);
        }

        .question-card {
            background: rgba(0, 0, 0, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.4);
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 8px 8px 0 rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .question-main {
            flex: 1;
            min-width: 0;
        }

        .question-type-label {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 20px;
            font-weight: 500;
        }

        .word-info-panel {
            width: 300px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 20px;
            border-radius: 4px;
            display: none;
        }

        .word-info-panel.visible {
            display: block;
        }

        .word-info-panel h3 {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: white;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        }

        .word-info-item {
            margin-bottom: 12px;
        }

        .word-info-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 3px;
        }

        .word-info-value {
            color: white;
            font-size: 0.95rem;
            line-height: 1.4;
        }

        .word-info-pronunciation {
            font-family: 'Charis SIL', serif;
            font-size: 1.1rem;
        }

        .question-text {
            font-family: 'Cormorant Garamond', serif;
            font-size: 2rem;
            margin-bottom: 30px;
            color: white;
            text-align: center;
        }

        .answer-input {
            width: 100%;
            padding: 15px;
            font-size: 1.2rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-family: 'Work Sans', sans-serif;
            text-align: center;
            transition: all 0.3s ease;
        }

        .answer-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .answer-input:focus {
            outline: none;
            border-color: white;
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.15);
        }

        .options {
            display: grid;
            gap: 15px;
            margin-top: 20px;
        }

        .option-btn {
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            text-align: left;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        .option-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: white;
            transform: translateX(5px);
        }

        .option-btn.selected {
            background: white;
            color: rgb(34, 154, 255);
            border-color: white;
        }

        .quiz-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        .results {
            text-align: center;
            padding: 60px 40px;
        }

        .results h2 {
            font-family: 'Cormorant Garamond', serif;
            font-size: 3rem;
            margin-bottom: 30px;
        }

        .score {
            font-size: 5rem;
            font-weight: 700;
            color: white;
            font-family: 'Cormorant Garamond', serif;
            line-height: 1;
            margin-bottom: 20px;
        }

        .score-label {
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 40px;
        }

        .review-item {
            padding: 25px;
            margin-bottom: 20px;
            border-left: 4px solid rgba(255, 255, 255, 0.4);
            text-align: left;
            background: rgba(255, 255, 255, 0.1);
        }

        .review-item.correct {
            border-left-color: #4caf50;
            background: rgba(76, 175, 80, 0.2);
        }

        .review-item.incorrect {
            border-left-color: #ff5252;
            background: rgba(255, 82, 82, 0.2);
        }

        .section.hidden {
            display: none;
        }

        .section.slide-in {
            animation: slideInFromBottom 0.6s ease-out;
        }

        @keyframes slideInFromBottom {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 40px 20px;
            }

            .section {
                padding: 25px;
            }

            h1 {
                font-size: 3rem;
            }

            .stats {
                grid-template-columns: 1fr 1fr;
            }

            .question-card {
                flex-direction: column;
            }

            .word-info-panel {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>PolyGlot Quiz</h1>
            <p class="subtitle">Master Your Conlang</p>
        </header>

        <div id="setupView">
            <div class="section">
                <h2>Upload Language File</h2>
                <div class="upload-zone" id="uploadZone">
                    <div class="upload-icon">üìÅ</div>
                    <div class="upload-text">
                        <strong>Drop your .pgd file here</strong><br>
                        or click to browse
                    </div>
                    <input type="file" id="fileInput" accept=".pgd">
                </div>
                <div class="file-info" id="fileInfo">
                    <div class="file-name" id="fileName"></div>
                    <div class="stats">
                        <div class="stat">
                            <div class="stat-value" id="wordCount">0</div>
                            <div class="stat-label">Words</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="posCount">0</div>
                            <div class="stat-label">Parts of Speech</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section hidden" id="settingsSection">
                <h2>Quiz Settings</h2>
                <div class="controls">
                    <div class="control-group">
                        <label>Question Types (Select Multiple)</label>
                        <div class="checkbox-group">
                            <label class="checkbox-item">
                                <input type="checkbox" class="question-type" value="local-to-conlang" checked>
                                <span>Local Language ‚Üí Conlang</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" class="question-type" value="conlang-to-local" checked>
                                <span>Conlang ‚Üí Local Language</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" class="question-type" value="from-definition">
                                <span>From Definition</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" class="question-type" value="guess-pos">
                                <span>Guess Part of Speech</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" class="question-type" value="guess-class">
                                <span>Guess Lexical Class</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" class="question-type" value="from-pronunciation">
                                <span>From Pronunciation</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" class="question-type" value="guess-pronunciation">
                                <span>Guess Pronunciation</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" class="question-type" value="tf-translation">
                                <span>True/False Translation</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" class="question-type" value="phrasebook-translation">
                                <span>Phrasebook Translation</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" class="question-type" value="phrasebook-tf">
                                <span>Phrasebook True/False</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" class="question-type" value="guess-conjugation">
                                <span>Guess Conjugation</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" class="question-type" value="guess-conjugation-dimensions">
                                <span>Guess Conjugation Dimensions</span>
                            </label>
                        </div>
                    </div>

                    <div class="control-group">
                        <label for="answerFormat">Answer Format</label>
                        <select id="answerFormat">
                            <option value="multiple-choice">Multiple Choice Only</option>
                            <option value="text-input">Text Input Only</option>
                            <option value="both">Both (50/50 chance)</option>
                        </select>
                    </div>

                    <div class="control-group" id="numChoicesGroup">
                        <label for="numChoices">Number of Choices (Multiple Choice)</label>
                        <input type="number" id="numChoices" value="4" min="2" max="10">
                    </div>

                    <div class="control-group">
                        <label for="numQuestions">Number of Questions</label>
                        <input type="number" id="numQuestions" value="10" min="1" max="100">
                    </div>

                    <div class="control-group">
                        <label>Exclude Parts of Speech</label>
                        <div class="checkbox-group" id="excludePOS">
                            <!-- Dynamically populated -->
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Exclude Lexical Classes</label>
                        <div class="checkbox-group" id="excludeClasses">
                            <!-- Dynamically populated -->
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Additional Options</label>
                        <div class="checkbox-group">
                            <label class="checkbox-item">
                                <input type="checkbox" id="revealAnswer" checked>
                                <span>Reveal Answer After Wrong Guess</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" id="showWordInfo" checked>
                                <span>Show Word Info Panel</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" id="caseSensitive">
                                <span>Case Sensitive</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" id="accentSensitive">
                                <span>Accent Sensitive</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" id="posSensitiveChoices" checked>
                                <span>POS-Sensitive Multiple Choice</span>
                            </label>
                        </div>
                    </div>
                </div>
                <button id="startQuiz" disabled>Start Quiz</button>
            </div>
        </div>

        <div id="quizView" class="quiz-container">
            <div class="quiz-header">
                <div class="quiz-title" id="quizTitle">Quiz</div>
                <div class="quiz-progress" id="quizProgress">Question 1 of 10</div>
            </div>

            <div class="question-card" id="questionCard">
                <!-- Dynamically populated -->
            </div>

            <div class="quiz-actions">
                <button id="checkAnswer">Check Answer</button>
                <button id="nextQuestion" style="display: none;">Next Question</button>
            </div>
        </div>

        <div id="resultsView" class="quiz-container">
            <div class="section results">
                <h2>Quiz Complete!</h2>
                <div class="score" id="finalScore">0%</div>
                <div class="score-label" id="scoreDetails">0 / 0 correct</div>
                <div id="reviewSection"></div>
                <button id="newQuiz">Create New Quiz</button>
            </div>
        </div>
    </div>

    <script>
        // State management
        let languageData = null;
        let quizData = [];
        let currentQuestion = 0;
        let score = 0;
        let userAnswers = [];

        // DOM elements
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const wordCount = document.getElementById('wordCount');
        const posCount = document.getElementById('posCount');
        const startQuiz = document.getElementById('startQuiz');
        const setupView = document.getElementById('setupView');
        const quizView = document.getElementById('quizView');
        const resultsView = document.getElementById('resultsView');
        const settingsSection = document.getElementById('settingsSection');
        const answerFormat = document.getElementById('answerFormat');
        const numChoicesGroup = document.getElementById('numChoicesGroup');

        // Show/hide number of choices based on answer format
        answerFormat.addEventListener('change', () => {
            if (answerFormat.value === 'text-input') {
                numChoicesGroup.style.display = 'none';
            } else {
                numChoicesGroup.style.display = 'flex';
            }
        });

        // Upload zone interactions
        uploadZone.addEventListener('click', () => fileInput.click());

        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });

        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.name.endsWith('.pgd')) {
                handleFile(file);
            }
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleFile(file);
        });

        // Parse PolyGlot .pgd file (ZIP containing XML)
        function handleFile(file) {
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    // PolyGlot files are ZIP archives containing PGDictionary.xml
                    const zip = await JSZip.loadAsync(e.target.result);
                    
                    console.log('ZIP contents:', Object.keys(zip.files));
                    
                    // Look for the XML file (usually PGDictionary.xml)
                    const xmlFile = zip.file('PGDictionary.xml') || 
                                   zip.file(Object.keys(zip.files).find(name => name.endsWith('.xml')));
                    
                    if (!xmlFile) {
                        alert('No XML file found in the .pgd archive.');
                        return;
                    }

                    const xmlContent = await xmlFile.async('text');
                    console.log('XML extracted, length:', xmlContent.length);

                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
                    
                    // Check for parsing errors
                    const parseError = xmlDoc.querySelector('parsererror');
                    if (parseError) {
                        console.error('XML Parse Error:', parseError.textContent);
                        alert('Error parsing XML file. Please ensure it\'s a valid PolyGlot .pgd file.\n\nCheck browser console (F12) for details.');
                        return;
                    }

                    console.log('XML parsed successfully');
                    console.log('Root element:', xmlDoc.documentElement.tagName);
                    console.log('First few child elements:', Array.from(xmlDoc.documentElement.children).slice(0, 10).map(el => el.tagName));

                    languageData = parsePolyGlotXML(xmlDoc);
                    
                    console.log('Parsed data:', {
                        words: languageData.words.length,
                        pos: languageData.partsOfSpeech.size,
                        classes: languageData.lexicalClasses.size,
                        phrases: languageData.phrasebook.length,
                        conjugations: languageData.conjugations.size
                    });

                    if (languageData.words.length === 0) {
                        alert('No words found in file. The file may use a different XML structure.\n\nCheck browser console (F12) for details.');
                        return;
                    }

                    displayFileInfo(file.name, languageData);
                } catch (error) {
                    console.error('Error details:', error);
                    alert('Error reading file: ' + error.message + '\n\nCheck browser console (F12) for details.');
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function parsePolyGlotXML(xmlDoc) {
            const data = {
                words: [],
                partsOfSpeech: new Set(),
                lexicalClasses: new Set(),
                classGroupings: new Map(), // Maps "POS names" -> Set of class names
                classPairToCategoryMap: new Map(), // Maps "classID,valueID" -> category name
                posGlossMap: new Map(), // Maps POS name -> abbreviation
                languageName: '',
                phrasebook: [],
                conjugations: new Map()
            };

            // Get language name
            const langNameEl = xmlDoc.querySelector('languageProperties > langName');
            if (langNameEl) {
                data.languageName = langNameEl.textContent;
            }

            // Parse parts of speech
            const posElements = xmlDoc.querySelectorAll('partsOfSpeech > class');
            const posMap = new Map();
            const posGlossMap = new Map(); // Map POS name to abbreviation
            
            posElements.forEach(posEl => {
                const id = posEl.querySelector('classId')?.textContent;
                const name = posEl.querySelector('className')?.textContent;
                const gloss = posEl.querySelector('classGloss')?.textContent;
                
                if (id && name) {
                    posMap.set(id, name);
                    data.partsOfSpeech.add(name);
                    
                    // Store gloss/abbreviation if it exists
                    if (gloss && gloss.trim()) {
                        posGlossMap.set(name, gloss.trim());
                    }
                }
            });
            
            data.posGlossMap = posGlossMap;

            // Parse lexical classes (wordGrammarClassCollection)
            const classElements = xmlDoc.querySelectorAll('wordGrammarClassCollection > wordGrammarClassNode');
            const classMap = new Map(); // Maps "classID,valueID" -> value name
            const classPairToCategoryMap = new Map(); // Maps "classID,valueID" -> category name
            
            classElements.forEach(classEl => {
                const id = classEl.querySelector('wordGrammarClassID')?.textContent;
                const name = classEl.querySelector('wordGrammarClassName')?.textContent;
                const applyTypes = classEl.querySelector('wordGrammarApplyTypes')?.textContent || '';
                
                if (id && name) {
                    // Parse which POS this class applies to
                    const posIds = applyTypes.split(',').map(s => s.trim()).filter(Boolean);
                    const applicablePosNames = posIds
                        .map(posId => posMap.get(posId))
                        .filter(Boolean)
                        .join(', ');
                    
                    // Only map and add class VALUES
                    const valueElements = classEl.querySelectorAll('wordGrammarClassValueNode');
                    valueElements.forEach(valueEl => {
                        const valueId = valueEl.querySelector('wordGrammarClassValueId')?.textContent;
                        const valueName = valueEl.querySelector('wordGrammarClassValueName')?.textContent;
                        if (valueId && valueName) {
                            const pairKey = `${id},${valueId}`;
                            classMap.set(pairKey, valueName);
                            classPairToCategoryMap.set(pairKey, name); // Map the full pair to category
                            data.lexicalClasses.add(valueName);
                            
                            // Add value to the POS grouping
                            if (applicablePosNames) {
                                if (!data.classGroupings.has(applicablePosNames)) {
                                    data.classGroupings.set(applicablePosNames, new Set());
                                }
                                data.classGroupings.get(applicablePosNames).add(valueName);
                            }
                        }
                    });
                }
            });
            
            data.classPairToCategoryMap = classPairToCategoryMap;

            // Parse lexicon entries
            const lexiconEntries = xmlDoc.querySelectorAll('lexicon > word');
            lexiconEntries.forEach(wordEl => {
                const conlangWord = wordEl.querySelector('conWord')?.textContent || '';
                const localWord = wordEl.querySelector('localWord')?.textContent || '';
                const definition = wordEl.querySelector('definition')?.textContent || '';
                const posId = wordEl.querySelector('wordTypeId')?.textContent || '';
                const pronunciation = wordEl.querySelector('pronunciation')?.textContent || '';
                const etymology = wordEl.querySelector('wordEtymologyNotes')?.textContent || '';
                
                // Get part of speech name from ID
                const pos = posMap.get(posId) || 'Unknown';

                // Get lexical classes with their category info
                const classElements = wordEl.querySelectorAll('wordClassCollection > wordClassification');
                const lexicalClasses = [];
                const lexicalClassesWithCategory = [];
                
                Array.from(classElements).forEach(el => {
                    const classPair = el.textContent.trim(); // e.g., "2,6"
                    const valueName = classMap.get(classPair);
                    const categoryName = classPairToCategoryMap.get(classPair);
                    
                    if (valueName) {
                        lexicalClasses.push(valueName);
                        
                        // Store value with its category using the pair mapping
                        if (categoryName) {
                            lexicalClassesWithCategory.push({
                                value: valueName,
                                category: categoryName
                            });
                        }
                    }
                });

                if (conlangWord && localWord) {
                    data.words.push({
                        conlang: conlangWord,
                        translation: stripHTML(localWord),
                        definition: stripHTML(definition),
                        partOfSpeech: pos,
                        pronunciation: pronunciation,
                        lexicalClass: lexicalClasses.join(', '),
                        lexicalClassArray: lexicalClasses, // Store as array too for matching
                        lexicalClassesWithCategory: lexicalClassesWithCategory, // Store with category info
                        etymology: stripHTML(etymology)
                    });
                }
            });

            // Parse phrasebook
            const phrases = xmlDoc.querySelectorAll('phrasebook > phrase');
            phrases.forEach(phraseEl => {
                const conlangPhrase = phraseEl.querySelector('conPhrase')?.textContent || '';
                const localPhrase = phraseEl.querySelector('localPhrase')?.textContent || '';
                
                if (conlangPhrase && localPhrase) {
                    data.phrasebook.push({
                        conlang: conlangPhrase,
                        local: stripHTML(localPhrase)
                    });
                }
            });

            // Parse conjugations/declensions
            const declensions = xmlDoc.querySelectorAll('declensionCollection > declensionNode');
            declensions.forEach(declEl => {
                const baseWordId = declEl.querySelector('declensionRelId')?.textContent || '';
                const combinedId = declEl.querySelector('combinedDimId')?.textContent || '';
                const declensionText = declEl.querySelector('declensionText')?.textContent || '';
                
                // Find the base word
                const baseWordEl = Array.from(xmlDoc.querySelectorAll('lexicon > word')).find(w => 
                    w.querySelector('wordId')?.textContent === baseWordId
                );
                let baseWord = '';
                if (baseWordEl) {
                    baseWord = baseWordEl.querySelector('conWord')?.textContent || '';
                }
                
                if (baseWord && declensionText) {
                    if (!data.conjugations.has(baseWord)) {
                        data.conjugations.set(baseWord, []);
                    }
                    data.conjugations.get(baseWord).push({
                        form: declensionText,
                        dimensions: combinedId
                    });
                }
            });

            console.log('Parsed data:', data);
            console.log('Class groupings:', Array.from(data.classGroupings.entries()));
            return data;
        }

        // Utility to strip HTML tags from definition/translation text
        function stripHTML(html) {
            if (!html) return '';
            const div = document.createElement('div');
            div.innerHTML = html;
            return div.textContent || div.innerText || '';
        }

        function displayFileInfo(name, data) {
            fileName.textContent = name;
            wordCount.textContent = data.words.length;
            posCount.textContent = data.partsOfSpeech.size;
            fileInfo.classList.add('visible');

            // Show settings section with animation
            settingsSection.classList.remove('hidden');
            settingsSection.classList.add('slide-in');

            // Populate POS exclusion list
            const excludePOS = document.getElementById('excludePOS');
            excludePOS.innerHTML = '';
            data.partsOfSpeech.forEach(pos => {
                const label = document.createElement('label');
                label.className = 'checkbox-item';
                label.innerHTML = `
                    <input type="checkbox" class="exclude-pos" value="${pos}">
                    <span>${pos}</span>
                `;
                excludePOS.appendChild(label);
            });

            // Populate lexical class exclusion list grouped by POS
            const excludeClasses = document.getElementById('excludeClasses');
            excludeClasses.innerHTML = '';
            
            if (data.classGroupings && data.classGroupings.size > 0) {
                // Group classes by POS
                data.classGroupings.forEach((classes, posNames) => {
                    if (classes.size > 0) {
                        // Create a section header for this POS group
                        const header = document.createElement('div');
                        header.style.cssText = 'margin-top: 15px; margin-bottom: 8px; font-weight: 600; color: white; font-size: 0.9rem; opacity: 0.9;';
                        header.textContent = posNames;
                        excludeClasses.appendChild(header);

                        // Add checkboxes for each class in this group
                        classes.forEach(className => {
                            const label = document.createElement('label');
                            label.className = 'checkbox-item';
                            label.style.marginLeft = '15px';
                            label.innerHTML = `
                                <input type="checkbox" class="exclude-class" value="${className}">
                                <span>${className}</span>
                            `;
                            excludeClasses.appendChild(label);
                        });
                    }
                });
            } else if (data.lexicalClasses.size > 0) {
                // Fallback: show ungrouped if no grouping data
                data.lexicalClasses.forEach(cls => {
                    const label = document.createElement('label');
                    label.className = 'checkbox-item';
                    label.innerHTML = `
                        <input type="checkbox" class="exclude-class" value="${cls}">
                        <span>${cls}</span>
                    `;
                    excludeClasses.appendChild(label);
                });
            } else {
                excludeClasses.innerHTML = '<p style="color: rgba(255,255,255,0.6); font-style: italic;">No lexical classes found in file</p>';
            }

            // Enable start button
            startQuiz.disabled = false;
        }

        // Quiz generation
        startQuiz.addEventListener('click', () => {
            if (generateQuiz()) {
                setupView.style.display = 'none';
                quizView.classList.add('active');
                showQuestion();
            }
        });

        function generateQuiz() {
            // Get selected question types
            const selectedTypes = Array.from(document.querySelectorAll('.question-type:checked'))
                .map(cb => cb.value);
            
            if (selectedTypes.length === 0) {
                alert('Please select at least one question type!');
                return false;
            }

            const answerFormatSetting = document.getElementById('answerFormat').value;
            const numChoices = parseInt(document.getElementById('numChoices').value);
            const numQuestions = parseInt(document.getElementById('numQuestions').value);
            
            const excludedPOS = Array.from(document.querySelectorAll('.exclude-pos:checked'))
                .map(cb => cb.value);
            const excludedClasses = Array.from(document.querySelectorAll('.exclude-class:checked'))
                .map(cb => cb.value);

            // Filter words
            let availableWords = languageData.words.filter(w => 
                !excludedPOS.includes(w.partOfSpeech) &&
                !excludedClasses.includes(w.lexicalClass)
            );

            if (availableWords.length === 0) {
                alert('No words available with current filters!');
                return false;
            }

            // Filter question types based on data availability
            const validTypes = selectedTypes.filter(type => {
                if (type === 'phrasebook-translation' || type === 'phrasebook-tf') {
                    return languageData.phrasebook.length >= 5;
                }
                if (type === 'from-pronunciation' || type === 'guess-pronunciation') {
                    return availableWords.some(w => w.pronunciation);
                }
                if (type === 'guess-class') {
                    return availableWords.some(w => w.lexicalClass);
                }
                if (type === 'guess-conjugation' || type === 'guess-conjugation-dimensions') {
                    return languageData.conjugations.size > 0;
                }
                return true;
            });

            if (validTypes.length === 0) {
                alert('Selected question types require data not present in the file!');
                return false;
            }

            // Generate questions
            quizData = [];
            for (let i = 0; i < numQuestions; i++) {
                const questionType = validTypes[Math.floor(Math.random() * validTypes.length)];
                
                // Determine answer format for this question
                let answerFormat;
                if (answerFormatSetting === 'both') {
                    answerFormat = Math.random() < 0.5 ? 'multiple-choice' : 'text-input';
                } else {
                    answerFormat = answerFormatSetting;
                }

                // True/False questions are always multiple choice with 2 options
                if (questionType === 'tf-translation' || questionType === 'phrasebook-tf') {
                    answerFormat = 'multiple-choice';
                }

                const question = generateQuestion(questionType, availableWords, answerFormat, numChoices);
                if (question) {
                    quizData.push(question);
                }
            }

            if (quizData.length === 0) {
                alert('Could not generate any questions!');
                return false;
            }

            currentQuestion = 0;
            score = 0;
            userAnswers = [];
            return true;
        }

        function generateQuestion(type, words, answerFormat, numChoices) {
            let question = {
                type: type,
                answerFormat: answerFormat
            };

            switch(type) {
                case 'local-to-conlang':
                    const word1 = words[Math.floor(Math.random() * words.length)];
                    question.prompt = word1.translation;
                    question.correctAnswer = word1.conlang;
                    question.word = word1;
                    if (answerFormat === 'multiple-choice') {
                        question.options = generateMultipleChoiceOptions(word1.conlang, words, 'conlang', numChoices, word1.partOfSpeech);
                    }
                    break;

                case 'conlang-to-local':
                    const word2 = words[Math.floor(Math.random() * words.length)];
                    question.prompt = word2.conlang;
                    question.correctAnswer = word2.translation;
                    question.word = word2;
                    if (answerFormat === 'multiple-choice') {
                        question.options = generateMultipleChoiceOptions(word2.translation, words, 'translation', numChoices, word2.partOfSpeech);
                    }
                    break;

                case 'from-definition':
                    const wordsWithDef = words.filter(w => w.definition);
                    if (wordsWithDef.length === 0) return null;
                    const word3 = wordsWithDef[Math.floor(Math.random() * wordsWithDef.length)];
                    question.prompt = word3.definition;
                    question.correctAnswer = word3.conlang;
                    question.word = word3;
                    if (answerFormat === 'multiple-choice') {
                        question.options = generateMultipleChoiceOptions(word3.conlang, words, 'conlang', numChoices, word3.partOfSpeech);
                    }
                    break;

                case 'guess-pos':
                    const word4 = words[Math.floor(Math.random() * words.length)];
                    question.prompt = word4.conlang;
                    question.correctAnswer = word4.partOfSpeech;
                    question.word = word4;
                    if (answerFormat === 'multiple-choice') {
                        question.options = generatePOSOptions(word4.partOfSpeech, numChoices);
                    }
                    break;

                case 'guess-class':
                    const wordsWithClass = words.filter(w => w.lexicalClass);
                    if (wordsWithClass.length === 0) return null;
                    const word5 = wordsWithClass[Math.floor(Math.random() * wordsWithClass.length)];
                    question.prompt = word5.conlang;
                    question.correctAnswer = word5.lexicalClass;
                    question.word = word5;
                    if (answerFormat === 'multiple-choice') {
                        question.options = generateClassOptions(word5.lexicalClass, word5.partOfSpeech, numChoices);
                    }
                    break;

                case 'from-pronunciation':
                    const wordsWithPron = words.filter(w => w.pronunciation);
                    if (wordsWithPron.length === 0) return null;
                    const word6 = wordsWithPron[Math.floor(Math.random() * wordsWithPron.length)];
                    question.prompt = word6.pronunciation;
                    question.correctAnswer = word6.conlang;
                    question.word = word6;
                    if (answerFormat === 'multiple-choice') {
                        question.options = generateMultipleChoiceOptions(word6.conlang, wordsWithPron, 'conlang', numChoices, word6.partOfSpeech);
                    }
                    break;

                case 'guess-pronunciation':
                    const wordsWithPron2 = words.filter(w => w.pronunciation);
                    if (wordsWithPron2.length === 0) return null;
                    const word7 = wordsWithPron2[Math.floor(Math.random() * wordsWithPron2.length)];
                    question.prompt = word7.conlang;
                    question.correctAnswer = word7.pronunciation;
                    question.word = word7;
                    if (answerFormat === 'multiple-choice') {
                        question.options = generateMultipleChoiceOptions(word7.pronunciation, wordsWithPron2, 'pronunciation', numChoices, word7.partOfSpeech);
                    }
                    break;

                case 'tf-translation':
                    const word8 = words[Math.floor(Math.random() * words.length)];
                    const isCorrect = Math.random() < 0.5;
                    question.prompt = `${word8.conlang} = ${isCorrect ? word8.translation : getRandomWordOfSamePOS(words, word8).translation}`;
                    question.correctAnswer = isCorrect ? 'True' : 'False';
                    question.options = ['True', 'False'];
                    question.word = word8;
                    break;

                case 'phrasebook-translation':
                    if (languageData.phrasebook.length < 5) return null;
                    const phrase1 = languageData.phrasebook[Math.floor(Math.random() * languageData.phrasebook.length)];
                    question.prompt = phrase1.local;
                    question.correctAnswer = phrase1.conlang;
                    question.isPhrase = true;
                    if (answerFormat === 'multiple-choice') {
                        question.options = generatePhraseOptions(phrase1.conlang, numChoices);
                    }
                    break;

                case 'phrasebook-tf':
                    if (languageData.phrasebook.length < 5) return null;
                    const phrase2 = languageData.phrasebook[Math.floor(Math.random() * languageData.phrasebook.length)];
                    const isPhraseCorrect = Math.random() < 0.5;
                    const displayPhrase = isPhraseCorrect ? phrase2.conlang : 
                        languageData.phrasebook[Math.floor(Math.random() * languageData.phrasebook.length)].conlang;
                    question.prompt = `${phrase2.local} ‚Üí ${displayPhrase}`;
                    question.correctAnswer = isPhraseCorrect ? 'True' : 'False';
                    question.options = ['True', 'False'];
                    question.isPhrase = true;
                    break;

                case 'guess-conjugation':
                    const conjugatedWords = Array.from(languageData.conjugations.keys());
                    if (conjugatedWords.length === 0) return null;
                    const baseWord = conjugatedWords[Math.floor(Math.random() * conjugatedWords.length)];
                    const conjugations = languageData.conjugations.get(baseWord);
                    const targetConj = conjugations[Math.floor(Math.random() * conjugations.length)];
                    question.prompt = `${baseWord} (${targetConj.dimensions})`;
                    question.correctAnswer = targetConj.form;
                    if (answerFormat === 'multiple-choice') {
                        question.options = conjugations.map(c => c.form).slice(0, numChoices);
                        if (!question.options.includes(targetConj.form)) {
                            question.options[0] = targetConj.form;
                        }
                        question.options = shuffleArray(question.options);
                    }
                    break;

                case 'guess-conjugation-dimensions':
                    const conjugatedWords2 = Array.from(languageData.conjugations.keys());
                    if (conjugatedWords2.length === 0) return null;
                    const baseWord2 = conjugatedWords2[Math.floor(Math.random() * conjugatedWords2.length)];
                    const conjugations2 = languageData.conjugations.get(baseWord2);
                    const targetConj2 = conjugations2[Math.floor(Math.random() * conjugations2.length)];
                    question.prompt = `${baseWord2} ‚Üí ${targetConj2.form}`;
                    question.correctAnswer = targetConj2.dimensions;
                    if (answerFormat === 'multiple-choice') {
                        question.options = conjugations2.map(c => c.dimensions).slice(0, numChoices);
                        if (!question.options.includes(targetConj2.dimensions)) {
                            question.options[0] = targetConj2.dimensions;
                        }
                        question.options = shuffleArray(question.options);
                    }
                    break;
            }

            return question;
        }

        function getRandomWordOfSamePOS(words, currentWord) {
            const samePOS = words.filter(w => w.partOfSpeech === currentWord.partOfSpeech && w.conlang !== currentWord.conlang);
            return samePOS.length > 0 ? samePOS[Math.floor(Math.random() * samePOS.length)] : currentWord;
        }

        function generateMultipleChoiceOptions(correctAnswer, words, field, numChoices, pos) {
            const posSensitive = document.getElementById('posSensitiveChoices').checked;
            const options = [correctAnswer];
            
            let pool = words.map(w => w[field]).filter(val => val && val !== correctAnswer);
            
            if (posSensitive && pos) {
                pool = words.filter(w => w.partOfSpeech === pos).map(w => w[field]).filter(val => val && val !== correctAnswer);
            }

            while (options.length < numChoices && pool.length > 0) {
                const randomIndex = Math.floor(Math.random() * pool.length);
                const option = pool.splice(randomIndex, 1)[0];
                if (!options.includes(option)) {
                    options.push(option);
                }
            }

            return shuffleArray(options);
        }

        function generatePOSOptions(correctPOS, numChoices) {
            const allPOS = Array.from(languageData.partsOfSpeech);
            const options = [correctPOS];
            
            const otherPOS = allPOS.filter(p => p !== correctPOS);
            while (options.length < numChoices && otherPOS.length > 0) {
                const randomIndex = Math.floor(Math.random() * otherPOS.length);
                options.push(otherPOS.splice(randomIndex, 1)[0]);
            }

            return shuffleArray(options);
        }

        function generateClassOptions(correctClass, pos, numChoices) {
            const posSensitive = document.getElementById('posSensitiveChoices').checked;
            const allClasses = Array.from(languageData.lexicalClasses);
            const options = [correctClass];
            
            let availableClasses;
            if (posSensitive) {
                // Find classes that apply to this POS
                availableClasses = [];
                languageData.classGroupings.forEach((classes, posNames) => {
                    if (posNames.includes(pos)) {
                        classes.forEach(cls => {
                            if (cls !== correctClass) {
                                availableClasses.push(cls);
                            }
                        });
                    }
                });
                
                // If no POS-specific classes found, fall back to all classes
                if (availableClasses.length === 0) {
                    availableClasses = allClasses.filter(c => c !== correctClass);
                }
            } else {
                availableClasses = allClasses.filter(c => c !== correctClass);
            }
            
            while (options.length < numChoices && availableClasses.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableClasses.length);
                options.push(availableClasses.splice(randomIndex, 1)[0]);
            }

            return shuffleArray(options);
        }

        function generatePhraseOptions(correctPhrase, numChoices) {
            const options = [correctPhrase];
            const otherPhrases = languageData.phrasebook.map(p => p.conlang).filter(p => p !== correctPhrase);
            
            while (options.length < numChoices && otherPhrases.length > 0) {
                const randomIndex = Math.floor(Math.random() * otherPhrases.length);
                options.push(otherPhrases.splice(randomIndex, 1)[0]);
            }

            return shuffleArray(options);
        }

        function showQuestion() {
            const q = quizData[currentQuestion];

            document.getElementById('quizProgress').textContent = 
                `Question ${currentQuestion + 1} of ${quizData.length}`;

            // Get question type display name
            const questionTypeNames = {
                'local-to-conlang': 'Local Language ‚Üí Conlang',
                'conlang-to-local': 'Conlang ‚Üí Local Language',
                'from-definition': 'From Definition',
                'guess-pos': 'Guess Part of Speech',
                'guess-class': 'Guess Lexical Class',
                'from-pronunciation': 'From Pronunciation',
                'guess-pronunciation': 'Guess Pronunciation',
                'tf-translation': 'True/False Translation',
                'phrasebook-translation': 'Phrasebook Translation',
                'phrasebook-tf': 'Phrasebook True/False',
                'guess-conjugation': 'Guess Conjugation',
                'guess-conjugation-dimensions': 'Guess Conjugation Dimensions'
            };

            let questionHTML = `
                <div class="question-main">
                    <div class="question-type-label">${questionTypeNames[q.type] || q.type}</div>
                    <div class="question-text">${q.prompt}</div>
            `;

            if (q.answerFormat === 'text-input') {
                questionHTML += `<input type="text" class="answer-input" id="userAnswer" placeholder="Type your answer..." autocomplete="off">`;
            } else {
                questionHTML += `<div class="options">`;
                q.options.forEach((option, idx) => {
                    questionHTML += `<button class="option-btn" data-option="${option}">${option}</button>`;
                });
                questionHTML += `</div>`;
            }

            questionHTML += `</div>`;

            // Add word info panel (initially hidden)
            questionHTML += `<div class="word-info-panel" id="wordInfoPanel"></div>`;

            document.getElementById('questionCard').innerHTML = questionHTML;

            // Add option selection for multiple choice
            if (q.answerFormat === 'multiple-choice') {
                document.querySelectorAll('.option-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.option-btn').forEach(b => 
                            b.classList.remove('selected'));
                        btn.classList.add('selected');
                    });
                });
            }

            // Focus input for text questions
            if (q.answerFormat === 'text-input') {
                const input = document.getElementById('userAnswer');
                input.focus();
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('checkAnswer').click();
                    }
                });
            }

            document.getElementById('checkAnswer').style.display = 'inline-block';
            document.getElementById('nextQuestion').style.display = 'none';
        }

        // Utility function to remove accents
        function removeAccents(str) {
            return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        }

        // Check answer
        document.getElementById('checkAnswer').addEventListener('click', () => {
            const q = quizData[currentQuestion];
            const caseSensitive = document.getElementById('caseSensitive').checked;
            const accentSensitive = document.getElementById('accentSensitive').checked;
            const revealAnswer = document.getElementById('revealAnswer').checked;
            const showWordInfo = document.getElementById('showWordInfo').checked;
            
            let userAnswer;

            if (q.answerFormat === 'text-input') {
                userAnswer = document.getElementById('userAnswer').value.trim();
            } else {
                const selected = document.querySelector('.option-btn.selected');
                userAnswer = selected ? selected.dataset.option : '';
            }

            let correct = false;

            // Special handling for different question types
            if (q.type === 'guess-pos') {
                // Accept either full name or abbreviation for POS
                correct = checkPOSAnswer(userAnswer, q.correctAnswer, caseSensitive, accentSensitive);
            } else if (q.type === 'guess-class') {
                // Accept any of the word's lexical classes or all of them
                correct = checkLexicalClassAnswer(userAnswer, q.word, caseSensitive, accentSensitive);
            } else {
                // Normal answer checking
                let normalizedUser = userAnswer;
                let normalizedCorrect = q.correctAnswer;

                if (!caseSensitive) {
                    normalizedUser = normalizedUser.toLowerCase();
                    normalizedCorrect = normalizedCorrect.toLowerCase();
                }

                if (!accentSensitive) {
                    normalizedUser = removeAccents(normalizedUser);
                    normalizedCorrect = removeAccents(normalizedCorrect);
                }

                correct = normalizedUser === normalizedCorrect;
            }

            if (correct) score++;

            userAnswers.push({
                question: q,
                userAnswer: userAnswer,
                correct: correct
            });

            // Show feedback in the main area
            const questionMain = document.querySelector('.question-main');
            const feedback = document.createElement('div');
            feedback.style.cssText = `
                margin-top: 20px; 
                padding: 20px; 
                border-left: 4px solid ${correct ? '#4caf50' : '#ff5252'};
                background: ${correct ? 'rgba(76, 175, 80, 0.2)' : 'rgba(255, 82, 82, 0.2)'};
                color: white;
            `;
            
            let feedbackHTML = `<strong>${correct ? '‚úì Correct!' : '‚úó Incorrect'}</strong><br>`;
            if (!correct && revealAnswer) {
                feedbackHTML += `The correct answer is: <strong>${q.correctAnswer}</strong>`;
            }
            
            feedback.innerHTML = feedbackHTML;
            questionMain.appendChild(feedback);

            // Show word info panel if enabled and this question is about a specific word
            if (showWordInfo && q.word && !q.isPhrase) {
                showWordInfoPanel(q.word);
            }

            document.getElementById('checkAnswer').style.display = 'none';
            document.getElementById('nextQuestion').style.display = 'inline-block';
        });

        function checkPOSAnswer(userAnswer, correctPOS, caseSensitive, accentSensitive) {
            // Normalize the user's answer
            let normalized = userAnswer;
            if (!caseSensitive) normalized = normalized.toLowerCase();
            if (!accentSensitive) normalized = removeAccents(normalized);

            // Normalize the correct POS name
            let normalizedCorrect = correctPOS;
            if (!caseSensitive) normalizedCorrect = normalizedCorrect.toLowerCase();
            if (!accentSensitive) normalizedCorrect = removeAccents(normalizedCorrect);

            // Check if matches full name
            if (normalized === normalizedCorrect) return true;

            // Check if matches abbreviation
            const gloss = languageData.posGlossMap.get(correctPOS);
            if (gloss) {
                let normalizedGloss = gloss;
                if (!caseSensitive) normalizedGloss = normalizedGloss.toLowerCase();
                if (!accentSensitive) normalizedGloss = removeAccents(normalizedGloss);
                
                if (normalized === normalizedGloss) return true;
            }

            return false;
        }

        function checkLexicalClassAnswer(userAnswer, word, caseSensitive, accentSensitive) {
            if (!word.lexicalClassArray || word.lexicalClassArray.length === 0) return false;

            // Normalize the user's answer
            let normalized = userAnswer;
            if (!caseSensitive) normalized = normalized.toLowerCase();
            if (!accentSensitive) normalized = removeAccents(normalized);

            // Try parsing as multiple classes (space, comma-space, or semicolon-space separated)
            const separators = [', ', '; ', ' '];
            let userClasses = [normalized]; // Default: treat as single class
            
            for (const sep of separators) {
                if (normalized.includes(sep)) {
                    userClasses = normalized.split(sep).map(c => c.trim()).filter(Boolean);
                    break;
                }
            }

            // Normalize the word's lexical classes
            const normalizedWordClasses = word.lexicalClassArray.map(cls => {
                let norm = cls;
                if (!caseSensitive) norm = norm.toLowerCase();
                if (!accentSensitive) norm = removeAccents(norm);
                return norm;
            });

            // Check if user provided one valid class
            if (userClasses.length === 1) {
                return normalizedWordClasses.includes(userClasses[0]);
            }

            // Check if user provided all classes (in any order)
            if (userClasses.length === normalizedWordClasses.length) {
                const sortedUser = [...userClasses].sort();
                const sortedWord = [...normalizedWordClasses].sort();
                return sortedUser.every((cls, idx) => cls === sortedWord[idx]);
            }

            return false;
        }

        function showWordInfoPanel(word) {
            const panel = document.getElementById('wordInfoPanel');
            if (!panel) return;

            let html = `<h3>Word Info</h3>`;

            html += `<div class="word-info-item">
                <div class="word-info-label">Conlang Word</div>
                <div class="word-info-value">${word.conlang}</div>
            </div>`;

            html += `<div class="word-info-item">
                <div class="word-info-label">Translation</div>
                <div class="word-info-value">${word.translation}</div>
            </div>`;

            if (word.pronunciation) {
                html += `<div class="word-info-item">
                    <div class="word-info-label">Pronunciation</div>
                    <div class="word-info-value word-info-pronunciation">/${word.pronunciation}/</div>
                </div>`;
            }

            html += `<div class="word-info-item">
                <div class="word-info-label">Part of Speech</div>
                <div class="word-info-value">${word.partOfSpeech}</div>
            </div>`;

            // Show lexical classes separately with their proper category names
            if (word.lexicalClassesWithCategory && word.lexicalClassesWithCategory.length > 0) {
                word.lexicalClassesWithCategory.forEach(classInfo => {
                    html += `<div class="word-info-item">
                        <div class="word-info-label">${classInfo.category}</div>
                        <div class="word-info-value">${classInfo.value}</div>
                    </div>`;
                });
            }

            if (word.definition) {
                html += `<div class="word-info-item">
                    <div class="word-info-label">Definition</div>
                    <div class="word-info-value">${word.definition}</div>
                </div>`;
            }

            if (word.etymology) {
                html += `<div class="word-info-item">
                    <div class="word-info-label">Etymology</div>
                    <div class="word-info-value">${word.etymology}</div>
                </div>`;
            }

            panel.innerHTML = html;
            panel.classList.add('visible');
        }

        // Next question
        document.getElementById('nextQuestion').addEventListener('click', () => {
            currentQuestion++;
            if (currentQuestion < quizData.length) {
                showQuestion();
            } else {
                showResults();
            }
        });

        function showResults() {
            quizView.classList.remove('active');
            resultsView.classList.add('active');

            const percentage = Math.round((score / quizData.length) * 100);
            document.getElementById('finalScore').textContent = `${percentage}%`;
            document.getElementById('scoreDetails').textContent = 
                `${score} out of ${quizData.length} correct`;

            // Show review
            const reviewSection = document.getElementById('reviewSection');
            reviewSection.innerHTML = '<h3 style="margin: 40px 0 20px; font-family: Cormorant Garamond, serif; font-size: 1.8rem;">Review</h3>';
            
            userAnswers.forEach((ans, idx) => {
                const div = document.createElement('div');
                div.className = `review-item ${ans.correct ? 'correct' : 'incorrect'}`;
                div.innerHTML = `
                    <strong>Q${idx + 1}:</strong> ${ans.question.prompt}<br>
                    <strong>Your answer:</strong> ${ans.userAnswer || '(no answer)'}<br>
                    <strong>Correct answer:</strong> ${ans.question.correctAnswer}
                `;
                reviewSection.appendChild(div);
            });
        }

        document.getElementById('newQuiz').addEventListener('click', () => {
            resultsView.classList.remove('active');
            setupView.style.display = 'block';
        });

        // Utility functions
        function shuffleArray(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }
    </script>
</body>
</html>
